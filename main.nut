// ---------------------------------------
// WormAI: A test in writing an OpenTTD AI
// First version based on WrightAI
// ---------------------------------------
//
// License: GNU GPL - version 2 (see license.txt)
// Author: Wormnest (Jacob Boerema)
// Copyright: Jacob Boerema - 2013-2015
//
// 

// Get the latest libversions
// This is autogenerated by a script to always have up to date version numbers
require("libversions.nut");

// Import SuperLib
import("util.superlib", "SuperLib", SUPERLIB_VERSION);

Result <- SuperLib.Result;
Log <- SuperLib.Log;
Helper <- SuperLib.Helper;
Data <- SuperLib.DataStore;
ScoreList <- SuperLib.ScoreList;
Money <- SuperLib.Money;

Tile <- SuperLib.Tile;
Direction <- SuperLib.Direction;

Engine <- SuperLib.Engine;
Vehicle <- SuperLib.Vehicle;

Station <- SuperLib.Station;
Airport <- SuperLib.Airport;
Industry <- SuperLib.Industry;
Town <- SuperLib.Town;

Order <- SuperLib.Order;
OrderList <- SuperLib.OrderList;

Road <- SuperLib.Road;
RoadBuilder <- SuperLib.RoadBuilder;

// Import List library
import("AILib.List", "ExtendedList", AILIBLIST_VERSION);


/* Wormnest: define some constants for easier maintenance. */
const MINIMUM_BALANCE_BUILD_AIRPORT = 100000;	/* Minimum bank balance to start building airports. */
const MINIMUM_BALANCE_AIRCRAFT = 25000;			/* Minimum bank balance to allow buying a new aircraft. */
const MINIMUM_BALANCE_TWO_AIRCRAFT = 5000000;	/* Minimum bank balance to allow buying 2 aircraft at once. */

const AIRCRAFT_LOW_PRICE_CUT = 500000;			/* Bank balance below which we will try to buy a low price aircraft. */
const AIRCRAFT_MEDIUM_PRICE_CUT = 2000000;		/* Bank balance below which we will try to buy a medium price aircraft. */
const AIRCRAFT_LOW_PRICE = 50000;				/* Maximum price of a low price aircraft. */
const AIRCRAFT_MEDIUM_PRICE = 250000;			/* Maximum price of a medium price aircraft. */
const AIRCRAFT_HIGH_PRICE = 1500000;			/* Maximum price of a high price aircraft. */

/* Default delays */
const SLEEPING_TIME = 100;						/* Default time to sleep between loops of our AI (NB: should be a multiple of 100). */
const DEFAULT_DELAY_BUILD_AIRPORT = 500; 		/* Default delay before building a new airport route. */

const STARTING_ACCEPTANCE_LIMIT = 150;			/* Starting limit in acceptance for finding suitable airport tile. */
const BAD_YEARLY_PROFIT = 10000;				/* Yearly profit limit below which profit is deemed bad. */
const AIRPORT_LIMIT_FACTOR = 3;					/* We limit airports to max aircraft / FACTOR * 2 (2 needed per route). */
const AIRPORT_CARGO_WAITING_LOW_LIMIT = 250;	/* Limit of waiting cargo (passengers) on airport above which we add an aircraft. */
const AIRPORT_CARGO_WAITING_HIGH_LIMIT = 1250;	/* Limit of waiting cargo (passengers) on airport above which we add 2 aircraft. */
const AIRPORT2_WAITING_DIFF = 150;				/* Cargo waiting diff (less) value at the other station to allow extra aircraft. */
const VEHICLE_AGE_LEFT_LIMIT = 150;				/* Number of days limit before maximum age for vehicle to get sent to depot for selling. */

/* ERROR CODE constants */
const ALL_OK = 0;
const ERROR_FIND_AIRPORT1	= -1;				/* There was an error finding a spot for airport 1. */
const ERROR_FIND_AIRPORT2	= -2;				/* There was an error finding a spot for airport 2. */
const ERROR_BUILD_AIRPORT1	= -3;				/* There was an error building airport 1. */
const ERROR_BUILD_AIRPORT2	= -4;				/* There was an error building airport 2. */
const ERROR_FIND_AIRPORT_ACCEPTANCE = -5;		/* We couldn't find a suitable airport but we lowered our acceptance rate limit so we can try again. */
const ERROR_FIND_AIRPORT_FINAL = -6;			/* We couldn't find a suitable airport and we are at the minimum acceptable acceptance limit. */
const ERROR_NO_SUITABLE_AIRPORT = -7;			/* There is no suitable airport type available. */
const ERROR_MAX_AIRCRAFT = -10;					/* We have reached the maximum allowed number of aircraft. */
const ERROR_MAX_AIRPORTS = -11;					/* We have reached the maximum number of airports. */
const ERROR_NOT_ENOUGH_MONEY = -20;				/* We don't have enough money. */
const ERROR_BUILD_AIRCRAFT = -30;				/* General error trying to build an aircraft. */
const ERROR_BUILD_AIRCRAFT_INVALID = -31;		/* No suitable aircraft found when trying to build an aircraft. */

class WormAI extends AIController {
	/* Declare the variables here. */
	name = null;
	towns_used = null;							/* town id, airport station tile */
	route_1 = null;								/* vehicle id, station_tile of first station in an order */
	route_2 = null;								/* vehicle id, station_tile of last station in an order */
	distance_of_route = {};						/* vehicle id, distance between first/last order stations */
	vehicle_to_depot = {};						/* vehicle id, boolean always true currently */
	ai_speed_factor = 1;						/* speed factor for our ai actions (1=fast..3=slow) */
	delay_build_airport_route = 0;
	passenger_cargo_id = -1;

	/* WormAI: New variables added. */
	/* Variables that need to be saved into a savegame. */
	
	/* DO NOT SAVE variables below this line. These will not be saved. */ 
	loaded_from_save = false;
	engine_usefulness = null;
	acceptance_limit = 0;				/* Starting limit for passenger acceptance for airport finding. */
	aircraft_disabled_shown = 0;		/* Has the aircraft disabled in game settings message been shown (1) or not (0). */
	aircraft_max0_shown = 0;			/* Has the max aircraft is 0 in game settings message been shown. */

	/* Our class constructor. */
	constructor()
	{
		/* Initialize the class variables here (or later when possible). */
		this.loaded_from_save = false;
		distance_of_route = {};
		vehicle_to_depot = {};
		this.towns_used = AIList();
		this.route_1 = AIList();
		this.route_2 = AIList();
		this.engine_usefulness = AIList();
		acceptance_limit = STARTING_ACCEPTANCE_LIMIT;
		this.aircraft_disabled_shown = 0;
		this.aircraft_max0_shown = 0;
		// Delays: we don't set them here but in start because we need to check the selected
		// speed set in game settings

		local list = AICargoList();
		for (local i = list.Begin(); !list.IsEnd(); i = list.Next()) {
			if (AICargo.HasCargoClass(i, AICargo.CC_PASSENGERS)) {
				this.passenger_cargo_id = i;
				break;
			}
		}
	}

	/* --- Implementation of base class functions. --- */
	function Start();
	function Save();
	function Load(version, data);
	
	/* --- Utility functions that should be moved to a separate unit. --- */
	/* Convert number to its hexadecimal string representation. */
	function decToHex(number);
	/* Writes a tile as a hexadecimal number. */
	function WriteTile(tile);
	/* Returns aircraft type as text. */
	function GetAircraftTypeAsText(airplane_id);
	/* Rough year/month age estimation string where year = 365 days and month = 30 days. */
	function GetAgeString(AgeInDays);
	/**
	 * This function taken from Rondje.
	 * Add a rectangular area to an AITileList containing tiles that are within /radius/
	 * tiles from the center tile, taking the edges of the map into account.
	 */  
	function SafeAddRectangle(list, tile, radius);
	
	/* --- Debugging output functions. --- */
	/* List of towns used and stations near those towns. */
	function DebugListTownsUsed();
	/* List all routes: per route all stations and all vehicles on that route with relevant info. */
	function DebugListRoutes();
	function DebugListRoute1(); 			/* Not used currently. */
	/* List all our air routes. */
	function DebugListRouteInfo();
	function DebugListRoute2(); 			/* Not used currently. */
	function DebugListDistanceOfRoute(); 	/* Not used currently. */

	/* --- Money related functions. --- */
	/* Check if we have enough money (via loan and on bank). */
	function HasMoney(money);
	/* Get the amount of money requested, loan if needed. */
	function GetMoney(money);
	
	/* --- Airport handling functions. --- */
	/**
	 * RemoveAirport. Remove airport at specified tile.
	 * If removing fails then give a warning.
	 * Note that using Sleep(x) here and trying again doesn't work for some reason (removing still fails)
	**/
	function RemoveAirport(tile);
	/**
	 * GetOptimalAvailableAirportType. Get the optimal type of airport that is available.
	 * For now we only choose between small, large and metropolitan. Larger ones would only
	 * be useful for very high cargo/passenger amounts with many airplanes.
	 * returns null if no suitable airport is available.
	**/
	function GetOptimalAvailableAirportType();
	/**
	 * Checks all airports to see if they can and should be upgraded.
	 * TODO If yes then starts the upgrade process.
	 * Because we might get stuck with 1 airport of a route being upgraded and the
	 * other still the old type (possibly different in size small/large) we are going
	 * to check the last airport of the orders first.
	**/
	function CheckForAirportsNeedingToBeUpgraded();
	/**
	 * Build an airport route. Find 2 cities that are big enough and try to build airport in both cities.
	 * Then we can build an aircraft and make some money.
	 * We limit our amount of airports to max aircraft / 3 * 2 (2 airports for a route, and 3 planes per route)
	 */
	function BuildAirportRoute();
	/**
	 * Find a suitable spot for an airport, walking all towns hoping to find one.
	 *  When a town is used, it is marked as such and not re-used.
	 */
	function FindSuitableAirportSpot(airport_type, center_tile);
	/**
	  * Sells the airports from tile_1 and tile_2
	  * Removes towns from towns_used list too
	  */
	function SellAirports(airport_1_tile, airport_2_tile);

	/* --- Order handling. --- */
	/**
	 * IsTownFirstOrder returns true if the airport near this town is used as the 
	 * first order, if false then it is used as the last/second order.
	**/
	function IsTownFirstOrder(town_id);

	/* --- Aircraft handling. --- */
	/* Get the maximum distance this aircraft can safely fly without landing. */
	function GetMaximumDistance(engine);
	/**
	 * Build an aircraft with orders from tile_1 to tile_2.
	 * The best available aircraft of that time will be bought.
	 * start_tile is the tile where the airplane should start, or 0 to start at the first tile.
	 */
	function BuildAircraft(tile_1, tile_2, start_tile);
	/*
	 * Send the vehicle to depot to be sold when it arrives.
	 * Vehicle - the vehicle id of the vehicle to be sold
	 * is_low_profit - boolean, if true sold because of low profit, false because of old age
	*/
	function SendToDepotForSelling(vehicle,is_low_profit);
	/*
	 * Sell the vehicle provided it's in depot. If it's not yet in depot it will fail silently.
	*/
	function SellVehicleInDepot(vehicle);
	/*
	 * Sell all vehicles in depot that are marked to be sold.
	*/
	function SellVehiclesInDepot();
	/* Checks if we can build an aircraft and if not outputs a string with the reason. */
	function CanBuildAircraft();

	/* --- Task related functions. --- */
	/*
	 * ManageVehicleRenewal will check all vehicles for being old or needing upgrading
	 * to a newer type. It will send all vehicles that are non optimal to depot for
	 * selling.
	 * Parameters:
	 * age_limit - the age in days left limit below which we send to depot for selling
	*/
	function ManageVehicleRenewal(age_limit);
	/* 
	 * Manage air routes: 
	 * - Send unprofitable aircraft to depot for selling
	 * - Add aircraft to routes that have a lot of waiting cargo
	 */
	function ManageAirRoutes();
	/* Callback that handles events. */
	function HandleEvents();
	/* 
	 * Task that once in a while evaluates all available aircraft for how suited they are
	 * for our purposes.
	 */
	function EvaluateAircraft();

	/* --- Valuator functions. --- */
	/* Get the cost factor of an aircraft. */
	function GetCostFactor(engine, costfactor_list);
	
	/* --- Initialization functions. --- */
	/*
	 * InitSettings initializes a number of required variables based on the game settings of our AI.
	*/
	function InitSettings();
	/*
	 * Welcome says hello to the user and prints out it's current AI gamesettings.
	 */
	function Welcome();

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Functions that should be moved to a utility/library unit
////////////////////////////////////////////////////////////////////////////////////////////////////

// Since it seems that Squirrel string library (with format and regexp) is not enabled in OpenTTD
// I used the following function to get a hexadecimal string.
// Source: http://forum.iv-multiplayer.com/index.php?topic=914.60
function WormAI::decToHex(number)
{
	local hexChars = "0123456789ABCDEF";
	local ret = "";
	local quotient = number;
	do
	{
		local remainder = quotient % 16;
		quotient /= 16;
		ret = hexChars[(remainder < 0) ? -remainder : remainder].tochar()+ret;
	}
	while(quotient != 0);
	if(number < 0) return "-"+ret;
	return ret;
}

// Writes a tile as a hexadecimal number
function WormAI::WriteTile(tile)
{
	return "0x" + decToHex(tile);
}

// Returns aircraft type as text
function WormAI::GetAircraftTypeAsText(airplane_id)
{
	// Get the aircraft type (mainly large/small)
	local planetype = "";
	switch(AIEngine.GetPlaneType(airplane_id)) {
		case AIAirport.PT_BIG_PLANE: {planetype = "Large airplane";} break;
		case AIAirport.PT_SMALL_PLANE: {planetype = "Small airplane";} break;
		case AIAirport.PT_HELICOPTER: {planetype = "Helicopter";} break;
		default: {planetype = "<invalid aircraft type>";} break;
	}
	return planetype;
}

/* Rough year/month age estimation string where year = 365 days and month = 30 days. */
function WormAI::GetAgeString(AgeInDays)
{
	local y = AgeInDays / 365;
	local days = AgeInDays - (y * 365);
	local m = days / 30;
	return y + " years " + m + " months";
}

//////////////////////////////////////////////////////////////////////////
//	Debugging functions

function WormAI::DebugListTownsUsed()
{
	AILog.Info("---------- DEBUG towns_used and related stations ----------");
	if (!this.towns_used) {
		AILog.Warning("WARNING: towns_used is null!");
	}
	else {
		AILog.Info("Number of towns used: " + this.towns_used.Count())
		//foreach(t in towns_used) {
		for (local t = towns_used.Begin(); !towns_used.IsEnd(); t = towns_used.Next()) {
			local tile = towns_used.GetValue(t);
			local is_city = (AITown.IsCity(t) ? "city" : "town");
			AILog.Info("Town: " + AITown.GetName(t) + " (id: " + t + "), " + is_city +
				", population: " + AITown.GetPopulation(t) + ", houses: " + AITown.GetHouseCount(t) +
				", grows every " + AITown.GetGrowthRate(t) + " days");
			AILog.Info("    Location: " + WriteTile(AITown.GetLocation(t)) +
				", station tile " + WriteTile(tile) + ").")
			local sid = AIStation.GetStationID(tile);
			local st_veh = AIVehicleList_Station(sid);
			AILog.Info("Station: " + AIStation.GetName(sid) + " (id: " + sid + "), waiting cargo: " + 
				AIStation.GetCargoWaiting(sid, passenger_cargo_id) + ", cargo rating: " + 
				AIStation.GetCargoRating(sid, passenger_cargo_id) + ", aircraft: " +
				st_veh.Count());
		}
	}
	AILog.Info("");
}

// List all routes: per route all stations and all vehicles on that route with relevant info
function WormAI::DebugListRoutes()
{
	AILog.Info("---------- DEBUG route info ----------");
		AILog.Info("Number of routes: " + (this.towns_used.Count() / 2) );
		for (local t = towns_used.Begin(); !towns_used.IsEnd(); t = towns_used.Next()) {
			local st_tile = towns_used.GetValue(t);
			// Find out whether this station is the first or last order
			local route1 = AIList();
			route1.AddList(route_1);
			// Keep only those with our station tile
			route1.KeepValue(st_tile);
			if (route1.Count() == 0) continue;
			// List from and to station names, and distance between them, and total profit of
			// all planes on route in the last year
			local st_id = AIStation.GetStationID(st_tile);
			local st_veh = AIVehicleList_Station(st_id);
			if (st_veh.Count() == 0) {
				AILog.Warning("Station " + AIStation.GetName(st_id) + " has 0 aircraft!");
				continue;
			}
			local first = true;
			local total_profit = 0;
			// Sort vehicle list on last years profit
			st_veh.Valuate(AIVehicle.GetProfitLastYear);
			for (local veh = st_veh.Begin(); !st_veh.IsEnd(); veh = st_veh.Next()) {
				if (first) {
					// Get list of stations this vehicle has in its orders
					local veh_stations = AIStationList_Vehicle(veh);
					local st_end_id = -1;
					foreach(veh_st_id, dummy_val in veh_stations) {
						// Since we have only 2 stations in our orders any id not the same
						// as st_id will be our target station id
						if (veh_st_id != st_id) {
							st_end_id = veh_st_id;
							break;
						}
					}
					local st_end_tile = route_2.GetValue(veh);
					local sq_dist = AITile.GetDistanceSquareToTile(st_tile, st_end_tile)
					AILog.Info( "Route from " + AIStation.GetName(st_id) +" ("+st_id+ ") to " +
						AIStation.GetName(st_end_id) +" ("+st_end_id+") "+
						", distance: " + sqrt(sq_dist).tointeger());
					first = false;
				}
				// Show info about aircraft
				AILog.Info("     " + AIVehicle.GetName(veh) + " (id: " + veh + "), age: " +
					GetAgeString(AIVehicle.GetAge(veh)) + ", capacity: " + 
					AIVehicle.GetCapacity(veh, passenger_cargo_id) + ", size: " + 
					GetAircraftTypeAsText(AIVehicle.GetEngineType(veh)) );
				local last_profit = AIVehicle.GetProfitLastYear(veh);
				// Increment total profit for this route
				total_profit += last_profit;
				AILog.Info("        Profit last year: " + last_profit + ", this year: " + 
					AIVehicle.GetProfitThisYear(veh));
			}
			AILog.Warning("     Total " + st_veh.Count() + " aircraft. Total profit last year: " + total_profit + ", average: " + (total_profit / st_veh.Count()));
		}
	AILog.Info("");
}

function WormAI::DebugListRoute1()
{
	//this.route_1.AddItem(vehicle, tile_1);
	//this.route_2.AddItem(vehicle, tile_2);
	AILog.Info("---------- DEBUG route_1 ----------");
	if (!this.route_1) {
		AILog.Warning("WARNING: route_1 is null!");
	}
	else {
		AILog.Info("Number or routes used: " + this.route_1.Count());
		for (local r = route_1.Begin(); !route_1.IsEnd(); r = route_1.Next()) {
			AILog.Info("Aircraft: " + AIVehicle.GetName(r) + " (id: " + r + ", tile " + WriteTile(route_1.GetValue(r)) + ").");
		}
	}
	AILog.Info("");
}

function WormAI::DebugListRouteInfo()
{
	//this.route_1.AddItem(vehicle, tile_1);
	//this.route_2.AddItem(vehicle, tile_2);
	local temp_route = AIList();
	temp_route.AddList(this.route_1); // so that we don't sort the original list
	AILog.Info("---------- DEBUG route info ----------");
	if (!temp_route) {
		AILog.Warning("WARNING: route list is null!");
	}
	else {
		temp_route.Sort(AIList.SORT_BY_ITEM, true);
		AILog.Info("Number of aircraft used: " + temp_route.Count());
		for (local r = temp_route.Begin(); !temp_route.IsEnd(); r = temp_route.Next()) {
			local tile1 = 0;
			local tile2 = 0;
			local t1 = 0;
			local t2 = 0;
			local route_start = AIList();
			local route_end = AIList();
			route_start.AddList(this.towns_used);
			route_end.AddList(this.towns_used);
			tile1 = temp_route.GetValue(r);
			tile2 = route_2.GetValue(r);
			route_start.KeepValue(tile1);
			t1 = route_start.Begin();
			route_end.KeepValue(tile2);
			t2 = route_end.Begin();
			local dist = this.distance_of_route.rawget(r);
			AILog.Info("Aircraft: " + AIVehicle.GetName(r) + " (id: " + r + "), from: " + 
				AITown.GetName(t1) + ", to: " + AITown.GetName(t2) + ", distance: " + dist);
		}
	}
	AILog.Info("");
}

function WormAI::DebugListRoute2()
{
	//this.route_1.AddItem(vehicle, tile_1);
	//this.route_2.AddItem(vehicle, tile_2);
	AILog.Info("---------- DEBUG route_2 ----------");
	if (!this.route_1) {
		AILog.Warning("WARNING: route_2 is null!");
	}
	else {
		AILog.Info("Number routes used: " + this.route_2.Count());
		for (local r = route_2.Begin(); !route_2.IsEnd(); r = route_2.Next()) {
			AILog.Info("Aircraft: " + AIVehicle.GetName(r) + " (id: " + r + ", tile " + WriteTile(route_2.GetValue(r)) + ").");
		}
	}
	AILog.Info("");
}

function WormAI::DebugListDistanceOfRoute()
{
	//this.distance_of_route.rawset(vehicle, AIMap.DistanceManhattan(tile_1, tile_2));
	AILog.Info("---------- DEBUG distance_of_route ----------");
	if (!this.route_1) {
		AILog.Warning("WARNING: route_2 is null!");
	}
	else {
		AILog.Info("Number routes used: " + this.route_2.Count());
		for (local r = route_2.Begin(); !route_2.IsEnd(); r = route_2.Next()) {
			AILog.Info("Aircraft: " + AIVehicle.GetName(r) + " (id: " + r + ", tile " + WriteTile(route_2.GetValue(r)) + ").");
		}
	}
	AILog.Info("");
}

//	End debugging functions
//////////////////////////////////////////////////////////////////////////

/**
 * Check if we have enough money (via loan and on bank).
 */
function WormAI::HasMoney(money)
{
	if (AICompany.GetBankBalance(AICompany.COMPANY_SELF) + (AICompany.GetMaxLoanAmount() - AICompany.GetLoanAmount()) >= money) return true;
	return false;
}

/**
 * Get the amount of money requested, loan if needed.
 * Return false if it failed, else true.
 */
function WormAI::GetMoney(money)
{
	if (!this.HasMoney(money)) {
		AILog.Info("We don't have enough money and we also can't loan enough for our needs (" + money + ").");
		AILog.Info("Bank balance: " + AICompany.GetBankBalance(AICompany.COMPANY_SELF) + 
			", max loan: " + AICompany.GetMaxLoanAmount() +
			", current loan: " + AICompany.GetLoanAmount());
		return false;
	}
	if (AICompany.GetBankBalance(AICompany.COMPANY_SELF) > money) return true;

	local loan = money - AICompany.GetBankBalance(AICompany.COMPANY_SELF) + AICompany.GetLoanInterval() + AICompany.GetLoanAmount();
	loan = loan - loan % AICompany.GetLoanInterval();
	AILog.Info("Need a loan to get " + money + ": " + loan);
	return AICompany.SetLoanAmount(loan);
}

/**
 * RemoveAirport. Remove airport at specified tile.
 * If removing fails then give a warning.
 * Note that using Sleep(x) here and trying again doesn't work for some reason (removing still fails)
**/
function WormAI::RemoveAirport(tile)
{
	if (!AIAirport.RemoveAirport(tile)) {
		AILog.Warning(AIError.GetLastErrorString());
		AILog.Warning("Failed to remove airport " + AIStation.GetName(AIStation.GetStationID(tile)) +
			" at tile " + WriteTile(tile) );
	}
}

/**
 * GetOptimalAvailableAirportType. Get the optimal type of airport that is available.
 * For now we only choose between small, large and metropolitan. Larger ones would only
 * be useful for very high cargo/passenger amounts with many airplanes.
 * returns null if no suitable airport is available.
**/
function WormAI::GetOptimalAvailableAirportType()
{
	local AirType = null;
	if (AIAirport.IsValidAirportType(AIAirport.AT_METROPOLITAN)) {
		AirType = AIAirport.AT_METROPOLITAN;
	}
	else if (AIAirport.IsValidAirportType(AIAirport.AT_LARGE)) {
		AirType = AIAirport.AT_LARGE;
	}
	else if (AIAirport.IsValidAirportType(AIAirport.AT_SMALL)) {
		AirType = AIAirport.AT_SMALL;
	}
	return AirType;
}

/**
 * IsTownFirstOrder returns true if the airport near this town is used as the 
 * first order, if false then it is used as the last/second order.
**/
function WormAI::IsTownFirstOrder(town_id)
{
	local station_tile = towns_used.GetValue(town_id);
	// Copy the list of First order routes
	local route1 = AIList();
	route1.AddList(route_1);
	// Keep only those with our station tile
	route1.KeepValue(station_tile);
	// return true if found (not 0) in route_1
	return (route1.Count() != 0);
}

/**
 * Checks all airports to see if they can and should be upgraded.
 * TODO If yes then starts the upgrade process.
 * Because we might get stuck with 1 airport of a route being upgraded and the
 * other still the old type (possibly different in size small/large) we are going
 * to check the last airport of the orders first.
**/
function WormAI::CheckForAirportsNeedingToBeUpgraded()
{
	AILog.Warning("Upgrading airports not yet implemented.");
	for (local t = towns_used.Begin(); !towns_used.IsEnd(); t = towns_used.Next()) {
		// TODO: Maybe use the station2 list and order by highest amount of waiting cargo to
		// choose the station to be converted first.
		if (!IsTownFirstOrder(t)) {
			AILog.Info("Upgrade check for: " + AITown.GetName(t));
			// Start looking at stations in towns that are the last/second order.
			local station_tile = towns_used.GetValue(t);
			local station_id = AIStation.GetStationID(station_tile);
			local airport_type = AIAirport.GetAirportType(station_tile);
			local optimal_airport = GetOptimalAvailableAirportType();
			if (airport_type != optimal_airport) {
				AILog.Info("Upgrade: Airport: " + AIStation.GetName(AIStation.GetStationID(station_tile)) + " needs upgrading!");
				// Needs upgrading if possible...
				// TODO: Remove airplanes from airport!
				local upgrade_list = [optimal_airport];
				Airport.UpgradeAirportInTown(t, station_id, upgrade_list, this.passenger_cargo_id, this.passenger_cargo_id);
				// Need to check if it succeeds and if it did:
				// Need to get the station id of the upgraded station
			}
		}
	}
}

/**
 * Build an airport route. Find 2 cities that are big enough and try to build airport in both cities.
 * Then we can build an aircraft and make some money.
 * We limit our amount of airports to max aircraft / 3 * 2 (2 airports for a route, and 3 planes per route)
 */
function WormAI::BuildAirportRoute()
{
	// No sense building airports if we already have the max (or more because amount can be changed in game)
	local max_vehicles = Vehicle.GetVehicleLimit(AIVehicle.VT_AIR);
	if (max_vehicles <= this.route_1.Count()) {
		AILog.Info("We are not going to look for a new airport route. We already have the maximum number of aircraft.");
		return ERROR_MAX_AIRCRAFT;
	}
	
	// Check for our maximum allowed airports (max only set by our own script, not OpenTTD)
	local airport_count = this.towns_used.Count();
	if ((max_vehicles * 2 / AIRPORT_LIMIT_FACTOR) <= airport_count) {
		AILog.Info("Not building more airports. We already have a reasonable amount for the current aircraft limit.");
		return ERROR_MAX_AIRPORTS;
	}

	// See for capacity of different airport types:
	// Airport capacity test: http://www.tt-forums.net/viewtopic.php?f=2&t=47279
	local airport_type = GetOptimalAvailableAirportType();
	if (airport_type == null) {
		AILog.Warning("No suitable airport type available that we know how to use.");
		return ERROR_NO_SUITABLE_AIRPORT;
	}

	/* Get enough money to work with */
	if (!this.GetMoney(AIAirport.GetPrice(airport_type)*2 + AIRCRAFT_LOW_PRICE)) {
		// Can't get enough money
		return ERROR_NOT_ENOUGH_MONEY;
	}

	/* Show some info about what we are doing */
	AILog.Info(Helper.GetCurrentDateString() + " Trying to build an airport route");

	local tile_1 = this.FindSuitableAirportSpot(airport_type, 0);
	if (tile_1 < 0) {
		if ((this.towns_used.Count() == 0) && (tile_1 = ERROR_FIND_AIRPORT_ACCEPTANCE)) {
			// We don't have any airports yet so try again at a lower acceptance limit
			while(tile_1 == ERROR_FIND_AIRPORT_ACCEPTANCE) {
				tile_1 = this.FindSuitableAirportSpot(airport_type, 0);
			}
			if (tile_1 < 0) return ERROR_FIND_AIRPORT1;
		}
		else {
			return ERROR_FIND_AIRPORT1;
		}
	}
	local tile_2 = this.FindSuitableAirportSpot(airport_type, tile_1);
	if (tile_2 < 0) {
		// Check for 1, not 0, here since if we get here we have at least 1 airport.
		if ((this.towns_used.Count() == 1) && (tile_2 = ERROR_FIND_AIRPORT_ACCEPTANCE)) {
			// We don't have any airports yet so try again at a lower acceptance limit
			while(tile_2 == ERROR_FIND_AIRPORT_ACCEPTANCE) {
				tile_2 = this.FindSuitableAirportSpot(airport_type, 0);
			}
			if (tile_2 < 0) {
				this.towns_used.RemoveValue(tile_1);
				return ERROR_FIND_AIRPORT2;
			}
		}
		else {
			this.towns_used.RemoveValue(tile_1);
			return ERROR_FIND_AIRPORT2;
		}
	}

	/* In certain cases building an airport still fails for unknown reason. */
	/* Build the airports for real */
	if (!AIAirport.BuildAirport(tile_1, airport_type, AIStation.STATION_NEW)) {
		AILog.Warning(AIError.GetLastErrorString());
		AILog.Error("Although the testing told us we could build an airport, it still failed at tile " + WriteTile(tile_1) + ".");
		this.towns_used.RemoveValue(tile_1);
		this.towns_used.RemoveValue(tile_2);
		return ERROR_BUILD_AIRPORT1;
	}
	if (!AIAirport.BuildAirport(tile_2, airport_type, AIStation.STATION_NEW)) {
		AILog.Warning(AIError.GetLastErrorString());
		AILog.Error("Although the testing told us we could build an airport, it still failed at tile " + WriteTile(tile_2) + ".");
		this.RemoveAirport(tile_1);
		this.towns_used.RemoveValue(tile_1);
		this.towns_used.RemoveValue(tile_2);
		return ERROR_BUILD_AIRPORT1;
	}

	local ret = this.BuildAircraft(tile_1, tile_2, tile_1);
	if (ret < 0) {
		// For some reason removing an airport in here sometimes fails, sleeping a little
		// helps for the cases we have seen.
		Sleep(1);
		this.RemoveAirport(tile_1);
		this.RemoveAirport(tile_2);
		this.towns_used.RemoveValue(tile_1);
		this.towns_used.RemoveValue(tile_2);
		AILog.Info("Cancelled route because we couldn't build an aircraft.");
	}
	else {
		local balance = AICompany.GetBankBalance(AICompany.COMPANY_SELF);
		if ((balance >= MINIMUM_BALANCE_TWO_AIRCRAFT) && (Vehicle.GetVehicleLimit(AIVehicle.VT_AIR) > this.route_1.Count())) {
			/* Build a second aircraft and start it at the other airport. */
			ret = this.BuildAircraft(tile_1, tile_2, tile_2);
		}
		AILog.Info("Done building a route");
	}

	AILog.Info("");
	
	return ret;
}

function WormAI::GetMaximumDistance(engine) {
	local max_dist = AIEngine.GetMaximumOrderDistance(engine);
	if (max_dist == 0) {
		/* Unlimited distance. Since we need to be able to keep values above a squared distance
		We set it to a predefined maximum value. Maps can be maximum 4096x4096. Diagonal will
		be more than that. To be safe we compute 10000 * 10000. */
		return 10000 * 10000;
	}
	else {
		return max_dist;
	}
}

/**
 * Build an aircraft with orders from tile_1 to tile_2.
 * The best available aircraft of that time will be bought.
 * start_tile is the tile where the airplane should start, or 0 to start at the first tile.
 */
function WormAI::BuildAircraft(tile_1, tile_2, start_tile)
{
	// Don't try to build aircraft if we already have the max (or more because amount can be changed in game)
	if (Vehicle.GetVehicleLimit(AIVehicle.VT_AIR) <= this.route_1.Count()) {
		AILog.Warning("Can't buy aircraft. We already have the maximum number allowed.");
		return ERROR_MAX_AIRCRAFT;
	}

	/* order_start_tile: where our order should start */
	local order_start_tile = start_tile;
	if (start_tile == 0) {
		order_start_tile = tile_1;
	}
	/* Build an aircraft */
	local hangar = AIAirport.GetHangarOfAirport(order_start_tile);
	local engine = null;
	local eng_price = 0;

	local engine_list = AIEngineList(AIVehicle.VT_AIR);

	/* When bank balance < AIRCRAFT_LOW_PRICE_CUT, buy cheaper planes */
	local balance = AICompany.GetBankBalance(AICompany.COMPANY_SELF);
	
	/* Balance below a certain minimum? Wait until we buy more planes. */
	if (balance < MINIMUM_BALANCE_AIRCRAFT) {
		AILog.Warning("We are low on money (" + balance + "). We are not going to buy an aircraft right now.");
		return ERROR_NOT_ENOUGH_MONEY;
	}
	
	/* We don't want helicopters so weed them out. */
	/* Might not be necessary since they are most likely never the most profitable. */
	engine_list.Valuate(AIEngine.GetPlaneType);
	engine_list.RemoveValue(AIAirport.PT_HELICOPTER);
	
	/*  We can't use large planes on small airports. Filter them out if needed.
		In fact if there is at least 1 small airport part of this order, then all large planes
		should be removed. However, since we currently make airports in pairs
		we can safely assume for now that both airports will be of the same type.
	*/
	local airport_type = AIAirport.GetAirportType(order_start_tile);
	if (airport_type == AIAirport.AT_SMALL || airport_type == AIAirport.AT_COMMUTER ) {
		AILog.Info("Removing big planes from selection since we are building for a small airport.");
		engine_list.RemoveValue(AIAirport.PT_BIG_PLANE);
	}
	
	engine_list.Valuate(AIEngine.GetPrice);
	engine_list.KeepBelowValue(balance < AIRCRAFT_LOW_PRICE_CUT ? AIRCRAFT_LOW_PRICE : (balance < AIRCRAFT_MEDIUM_PRICE_CUT ? AIRCRAFT_MEDIUM_PRICE : AIRCRAFT_HIGH_PRICE));

	engine_list.Valuate(AIEngine.GetCargoType);
	engine_list.KeepValue(this.passenger_cargo_id);
	
	// Newer versions of OpenTTD allow NewGRFs to set a maximum distance a plane can fly between orders
	// That means we need to make sure planes can fly the distance necessary for our intended order.
	// Since distance is returned squared we need to get the squared distance for our intended order.
	engine_list.Valuate(this.GetMaximumDistance);
	//foreach (eng,x in engine_list) {
	//	AILog.Info("Engine: " + AIEngine.GetName(eng) + ", distance: " + AIEngine.GetMaximumOrderDistance(eng));
	//}
	//local distance_between_stations = AIOrder.GetOrderDistance(null, tile_1, tile_2);
	local distance_between_stations = AIMap.DistanceSquare(tile_1, tile_2);
	engine_list.KeepAboveValue(distance_between_stations);
	// debugging:
	//AILog.Info("squared distance: " + distance_between_stations);
	//foreach (eng,x in engine_list) {
	//	AILog.Info("Engine: " + AIEngine.GetName(eng) + ", distance: " + AIEngine.GetMaximumOrderDistance(eng));
	//}
	////////////

	//engine_list.Valuate(AIEngine.GetCapacity);
	//engine_list.KeepTop(1);
	engine_list.Valuate(WormAI.GetCostFactor, this.engine_usefulness);
	engine_list.KeepBottom(1);

	/* Make sure that there was a suitable engine found. */
	if (engine_list.Count() == 0) {
		// Most likely no aircraft found for the range we wanted.
		AILog.Warning("Couldn't find a suitable aircraft.");
		return ERROR_BUILD_AIRCRAFT_INVALID;
	}
	
	engine = engine_list.Begin();

	if (!AIEngine.IsValidEngine(engine)) {
		AILog.Warning("Couldn't find a suitable aircraft. Most likely we don't have enough available funds.");
		return ERROR_BUILD_AIRCRAFT_INVALID;
	}
	/* Price of cheapest engine can be more than our bank balance, check for that. */
	eng_price = AIEngine.GetPrice(engine);
	if (eng_price > balance) {
		AILog.Warning("Can't buy aircraft. The cheapest selected aircraft (" + eng_price + ") costs more than our available funds (" + balance + ").");
		return ERROR_NOT_ENOUGH_MONEY;
	}
	local vehicle = AIVehicle.BuildVehicle(hangar, engine);
	if (!AIVehicle.IsValidVehicle(vehicle)) {
		AILog.Warning(AIError.GetLastErrorString());
		AILog.Error("Couldn't build the aircraft: " + AIEngine.GetName(engine));
		return ERROR_BUILD_AIRCRAFT;
	}

	/* Send him on his way */
	/* If this isn't the first vehicle with this order, then make a shared order. */
	local veh_list = AIList();
	veh_list.AddList(this.route_1);
	veh_list.KeepValue(tile_1);
	if (veh_list.Count() > 0) {
		local share_veh = veh_list.Begin();
		AIOrder.ShareOrders(vehicle, share_veh);
		AILog.Info("Not the first vehicle: share orders.");
	}
	else {
		/* First vehicle with these orders. */
		AIOrder.AppendOrder(vehicle, tile_1, AIOrder.OF_FULL_LOAD_ANY);
		AIOrder.AppendOrder(vehicle, tile_2, AIOrder.OF_FULL_LOAD_ANY);
		AILog.Info("First vehicle: set orders.");
	}
	/* If vehicle should be started at another tile than tile_1 then skip to that order. */
	/* Currently always assumes it is tile_2 and that that is the second order, thus 1. */
	if (order_start_tile != tile_1) {
		AILog.Info("Order: skipping to other tile.");
		AIOrder.SkipToOrder(vehicle, 1);
	}
	
	/* When breakdowns are on add go to depot orders on every airport.
	   Ignore this when we added aircraft to shared orders. */
	if ((veh_list.Count() == 0) && (AIGameSettings.GetValue("difficulty.vehicle_breakdowns") > 0)) {
		/* Get the hangar tiles of both airports. */
		local Depot_Airport_1 = AIAirport.GetHangarOfAirport(tile_1);
		local Depot_Airport_2 = AIAirport.GetHangarOfAirport(tile_2);
		/* Add the depot orders: only go there if service is needed. */
		if (!AIOrder.InsertOrder(vehicle, 1, Depot_Airport_2, AIOrder.OF_SERVICE_IF_NEEDED ))
			{ AILog.Warning("Failed to insert go to depot order!"); }
		if (!AIOrder.InsertOrder(vehicle, 3, Depot_Airport_1, AIOrder.OF_SERVICE_IF_NEEDED ))
			{ AILog.Warning("Failed to insert go to depot order!"); }
	}
	
	AIVehicle.StartStopVehicle(vehicle);
	this.distance_of_route.rawset(vehicle, AIMap.DistanceManhattan(tile_1, tile_2));
	this.route_1.AddItem(vehicle, tile_1);
	this.route_2.AddItem(vehicle, tile_2);

	AILog.Info("Finished building aircraft " + AIVehicle.GetName(vehicle) + ", type: " + 
		AIEngine.GetName(engine) + ", price: " + eng_price );
	AILog.Info("Yearly running costs: " + AIEngine.GetRunningCost(engine) + ",  capacity: " + 
		AIEngine.GetCapacity(engine) + ", Maximum speed: " + AIEngine.GetMaxSpeed(engine) +
		", Maximum distance: " + AIEngine.GetMaximumOrderDistance(engine));

	return ALL_OK;
}

/**
 * This function taken from Rondje.
 * Add a rectangular area to an AITileList containing tiles that are within /radius/
 * tiles from the center tile, taking the edges of the map into account.
 */  
function SafeAddRectangle(list, tile, radius) {
	local x1 = max(0, AIMap.GetTileX(tile) - radius);
	local y1 = max(0, AIMap.GetTileY(tile) - radius);
	
	local x2 = min(AIMap.GetMapSizeX() - 2, AIMap.GetTileX(tile) + radius);
	local y2 = min(AIMap.GetMapSizeY() - 2, AIMap.GetTileY(tile) + radius);
	
	list.AddRectangle(AIMap.GetTileIndex(x1, y1),AIMap.GetTileIndex(x2, y2)); 
}

/**
 * Find a suitable spot for an airport, walking all towns hoping to find one.
 *  When a town is used, it is marked as such and not re-used.
 */
function WormAI::FindSuitableAirportSpot(airport_type, center_tile)
{
	local airport_x, airport_y, airport_rad;

	airport_x = AIAirport.GetAirportWidth(airport_type);
	airport_y = AIAirport.GetAirportHeight(airport_type);
	airport_rad = AIAirport.GetAirportCoverageRadius(airport_type);

	local town_list = AITownList();
	/* Remove all the towns we already used */
	town_list.RemoveList(this.towns_used);

	town_list.Valuate(AITown.GetPopulation);
	town_list.KeepAboveValue(GetSetting("min_town_size"));
	/* Keep the best 20, if we can't find 2 stations in there, just leave it anyway */
	/* Original value was 10. We increase it to 20 to make it more likely we will find
	   a town in case there are a lot of unsuitable locations. */
	town_list.KeepTop(20);
	town_list.Valuate(AIBase.RandItem);

	/* Now find 2 suitable towns */
	for (local town = town_list.Begin(); !town_list.IsEnd(); town = town_list.Next()) {
		/* Don't make this a CPU hog */
		Sleep(1);

		local tile = AITown.GetLocation(town);

		/* Create a 30x30 grid around the core of the town and see if we can find a spot for a small airport */
		local list = AITileList();
		/* Safely add a rectangle taking care of border tiles. */
		SafeAddRectangle(list, tile, 15);
		//list.AddRectangle(tile - AIMap.GetTileIndex(15, 15), tile + AIMap.GetTileIndex(15, 15));
		list.Valuate(AITile.IsBuildableRectangle, airport_x, airport_y);
		list.KeepValue(1);
		if (center_tile != 0) {
			/* If we have a tile defined, check to see if it's within the minimum and maximum allowed. */
			list.Valuate(AITile.GetDistanceSquareToTile, center_tile);
			local min_distance = GetSetting("min_airport_distance");
			local max_distance = GetSetting("max_airport_distance");
			/* Keep above minimum distance. */
			list.KeepAboveValue(min_distance * min_distance);
			/* Keep below maximum distance. */
			list.KeepBelowValue(max_distance * max_distance);
			// TODO: In early games with low maximum speeds we may need to adjust maximum and
			// maybe even minimum distance to get a round trip within a year.
		}
		/* Sort on acceptance, remove places that don't have acceptance */
		list.Valuate(AITile.GetCargoAcceptance, this.passenger_cargo_id, airport_x, airport_y, airport_rad);
		list.RemoveBelowValue(this.acceptance_limit);
		
		/** debug off
		for (tile = list.Begin(); !list.IsEnd(); tile = list.Next()) {
			AILog.Info("Town: " + AITown.GetName(town) + ", Tile: " + WriteTile(tile) +
				", Passenger Acceptance: " + list.GetValue(tile));
		} **/

		/* Couldn't find a suitable place for this town, skip to the next */
		if (list.Count() == 0) continue;
		/* Walk all the tiles and see if we can build the airport at all */
		{
			local test = AITestMode();
			local good_tile = 0;

			for (tile = list.Begin(); !list.IsEnd(); tile = list.Next()) {
				Sleep(1);
				if (!AIAirport.BuildAirport(tile, airport_type, AIStation.STATION_NEW)) continue;
				good_tile = tile;
				break;
			}

			/* Did we find a place to build the airport on? */
			if (good_tile == 0) continue;
		}

		AILog.Info("Found a good spot for an airport in " + AITown.GetName(town) + " (id: "+ town + 
			", tile " + WriteTile(tile) + ", acceptance: " + list.GetValue(tile) + ").");

		/* Mark the town as used, so we don't use it again */
		this.towns_used.AddItem(town, tile);

		return tile;
	}

	local ret = 0;
	if (this.acceptance_limit > 25) {
		this.acceptance_limit -= 25;
		ret = ERROR_FIND_AIRPORT_ACCEPTANCE;
		AILog.Info("Lowering acceptance limit for suitable airports to " + this.acceptance_limit );
	}
	else {
		// Maybe remove this? Minimum of 25 seems low enough.
		//this.acceptance_limit = 10;
		ret = ERROR_FIND_AIRPORT_FINAL;
	}
	AILog.Info("Couldn't find a suitable town to build an airport in");
	return ret;
}

/*
 * Send the vehicle to depot to be sold when it arrives.
 * Vehicle - the vehicle id of the vehicle to be sold
 * is_low_profit - boolean, if true sold because of low profit, false because of old age
*/
function WormAI::SendToDepotForSelling(vehicle,is_low_profit)
{
	/* Send the vehicle to depot if we didn't do so yet */
	if (!vehicle_to_depot.rawin(vehicle) || vehicle_to_depot.rawget(vehicle) != true) {
		local info_text = "--> Sending " + AIVehicle.GetName(vehicle) + " (id: " + vehicle + 
			") to depot because of ";
		if (is_low_profit) {
			info_text += "low profits: " + AIVehicle.GetProfitLastYear(vehicle) + " / " + 
				AIVehicle.GetProfitThisYear(vehicle);
		}
		else {
			info_text += "old age: " +  GetAgeString(AIVehicle.GetAge(vehicle)) + " / " + 
				GetAgeString(AIVehicle.GetMaxAge(vehicle));
		}
		AILog.Info(info_text);
		/* Send it to depot. */
		if (!AIVehicle.SendVehicleToDepot(vehicle))
		{
			AILog.Warning(AIError.GetLastErrorString());
			AILog.Warning("Failed to send vehicle " + AIVehicle.GetName(vehicle) + "to depot!");
		}
		else {
			/* Add it to our list of vehicles that were sent to depot. */
			vehicle_to_depot.rawset(vehicle, true);
		}
	}
}

/*
 * Sell the vehicle provided it's in depot. If it's not yet in depot it will fail silently.
*/
function WormAI::SellVehicleInDepot(vehicle)
{
	// Make sure vehicle occurs in vehicle_to_depot
	if ((vehicle_to_depot.rawin(vehicle) && vehicle_to_depot.rawget(vehicle) == true)) {
		local veh_name = AIVehicle.GetName(vehicle);
		// Try to sell the vehicle
		if (AIVehicle.SellVehicle(vehicle)) {
			AILog.Info("--> Sold " + veh_name + " (id: " + vehicle + ").");
			/* Check if we are the last one serving those airports; else sell the airports */
			local list2 = AIVehicleList_Station(AIStation.GetStationID(this.route_1.GetValue(vehicle)));
			if (list2.Count() == 0) {
				local t1 = route_1.GetValue(vehicle);
				local t2 = route_2.GetValue(vehicle);
				this.SellAirports(t1, t2);
			}
			/* Remove the aircraft from the routes. */
			route_1.RemoveItem(vehicle);
			route_2.RemoveItem(vehicle);
			/* Remove aircraft from our to_depot list. */
			vehicle_to_depot.rawdelete(vehicle);
		}
		else {
			/* Since vehicle not yet being in depot is an expected error we
			   won't show a log message for that. */
			if (AIError.GetLastError() != AIVehicle.ERR_VEHICLE_NOT_IN_DEPOT) {
				AILog.Warning(AIError.GetLastErrorString());
				AILog.Warning("Failed to sell vehicle " + AIVehicle.GetName(vehicle));
			}
		}
	}
}

/*
 * Sell all vehicles in depot that are marked to be sold.
*/
function WormAI::SellVehiclesInDepot()
{
	AILog.Info("- Check for vehicles waiting in depot to be sold.")
	// i = vehicle id, v = boolean, always true currently
	foreach( i,v in vehicle_to_depot) {
		SellVehicleInDepot(i);
	}
}

/*
 * ManageVehicleRenewal will check all vehicles for being old or needing upgrading
 * to a newer type. It will send all vehicles that are non optimal to depot for
 * selling.
 * Parameters:
 * age_limit - the age in days left limit below which we send to depot for selling
*/
function WormAI::ManageVehicleRenewal(age_limit)
{
	AILog.Info("- Check for vehicles that are old.")
	local list = AIVehicleList();
	list.Valuate(AIVehicle.GetAgeLeft);
	/* Keep vehicles whose age is below the limit we set. */
	list.KeepBelowValue(age_limit);
	/* Send them all to depot to be sold. */
	for (local veh = list.Begin(); !list.IsEnd(); veh = list.Next()) {
		SendToDepotForSelling(veh, false); // false = old age
	}
}

function WormAI::ManageAirRoutes()
{
	// TODO:
	// 1. Make groups for each route
	// 2. When we have max aircraft/airports:
	//  - Evaluate total profit per group, remove bad groups/airports or reduce # planes
	//  - Favor bigger/faster aircraft over cost more when high amount waiting passengers
	// 3. Upgrade aircraft when they are old or when newer ones would be more profitable
	// 4. Upgrade airports when possible
	// 5. Check reliability when breakdowns are on
	local list = AIVehicleList();
	local low_profit_limit = 0;
	
	/* Show some info about what we are doing */
	AILog.Info(Helper.GetCurrentDateString() + " Managing air routes.");
	
	list.Valuate(AIVehicle.GetAge);
	/* Give the plane at least 2 full years to make a difference, thus check for 3 years old. */
	list.KeepAboveValue(365 * 3);
	list.Valuate(AIVehicle.GetProfitLastYear);

	/* Decide on the best low profit limit at this moment. */
	if (Vehicle.GetVehicleLimit(AIVehicle.VT_AIR) > this.route_1.Count()) {
		/* Since we can still add more planes keep all planes that make at least some profit. */
		// TODO: When maintenance costs are on we should set low profit limit too at least
		// the yearly costs.
		low_profit_limit = 0;
		list.KeepBelowValue(low_profit_limit);
	}
	else {
		//  extensive computation for low profit limit.
		local list_count = 0;
		local list_copy = AIList();
		// Set default low yearly profit
		low_profit_limit = BAD_YEARLY_PROFIT;
		list_count = list.Count();
		// We need a copy of list before cutting off low_profit
		list_copy.AddList(list);
		list.KeepBelowValue(low_profit_limit);
		if (list.Count() == 0) {
			// All profits are above our current low_profit_limit
			// Get vehicle with last years highest profit
			// We need to get the vehicle list again because our other list has removed
			// vehicles younger than 3 years, we want the absolute high profit of all vehicles
			local highest = AIVehicleList();
			highest.Valuate(AIVehicle.GetProfitLastYear);
			highest.KeepTop(1);
			local v = highest.Begin();
			local high_profit = highest.GetValue(v);
			// get profits below 20% of that
			low_profit_limit = high_profit * 3 / 10; // TESTING: 30%
			// Copy the list_copy back to list which at this point is (should be) empty.
			list.AddList(list_copy);
			// Apparently need to use Valuate again on profit for it to work
			list.Valuate(AIVehicle.GetProfitLastYear);
			list.KeepBelowValue(low_profit_limit);
			// DEBUG:
			//foreach (i,v in list) {
			//	AILog.Info("Vehicle " + i + " has profit: " + v);
			//}
			AILog.Warning("Computed low_profit_limit: " + low_profit_limit + " (highest profit: " +
				high_profit + "), number below limit: " + list.Count());
		}
		else if (list_count == 0) {
			AILog.Info("All aircraft younger than 3 years: recomputing low_profit_limit not needed.");
		}
		else {
			AILog.Warning("There are " + list.Count() + " aircraft below last years bad yearly profit limit.");
		}
	}

	// TODO: Don't sell all aircraft from the same route all at once, try selling 1 per year?
	for (local i = list.Begin(); !list.IsEnd(); i = list.Next()) {
		/* Profit last year and this year bad? Let's sell the vehicle */
		SendToDepotForSelling(i, true); // true = low profit
		/* Sell vehicle provided it's in depot. If not we will get it a next time.
		   This line can also be removed probably since we handle selling once a 
		   month anyway. */
		SellVehicleInDepot(i);
	}

	/* Don't try to add planes when we are short on cash */
	if (!this.HasMoney(AIRCRAFT_LOW_PRICE)) return ERROR_NOT_ENOUGH_MONEY;
	else if (Vehicle.GetVehicleLimit(AIVehicle.VT_AIR) <= this.route_1.Count()) {
		// No sense building plane if we already have the max (or more because amount can be changed in game)
		AILog.Info("We already have the maximum number of aircraft. No need to check if we should add more planes.");
		return ERROR_MAX_AIRCRAFT;
	}

	list = AIStationList(AIStation.STATION_AIRPORT);
	list.Valuate(AIStation.GetCargoWaiting, this.passenger_cargo_id);
	list.KeepAboveValue(AIRPORT_CARGO_WAITING_LOW_LIMIT);

	for (local i = list.Begin(); !list.IsEnd(); i = list.Next()) {
		local list2 = AIVehicleList_Station(i);
		/* No vehicles going to this station, abort and sell */
		if (list2.Count() == 0) {
			// This can happen when after building 2 airports it fails to build an aircraft
			// due to lack of money or whatever and then removing one of the airports fails
			// due to unknown reasons. A fix that seems to help so far is doing a Sleep(1)
			// before removing the airports but just to be sure we check here anyway.
			// In that case tile_1 and 2 will be 0 although there still is a station.
			local t1 = this.route_1.GetValue(i);
			local t2 = this.route_2.GetValue(i);
			if ((t1 == 0) && (t2 == 0)) {
				AILog.Warning("Airport " + AIStation.GetName(i) + " still exists. Trying to remove it now.");
				this.RemoveAirport(AIStation.GetLocation(i));
			}
			else {
				AILog.Warning("***** Encountered station without vehicles, should not happen here! *****");
				AILog.Info("Station " + i + " = " + AIStation.GetName(i) );
				AILog.Info("Stations at tiles " + WriteTile(t1) + " and " + WriteTile(t2) );
				this.SellAirports(t1, t2);
			}
			continue;
		};

		/* Find the first vehicle that is going to this station */
		local v = list2.Begin();
		local dist = this.distance_of_route.rawget(v) / 2;
		
		/* Find the id of the other station and then request that stations waiting cargo. */
		local st = this.route_1.GetValue(v);
		if (st == AIStation.GetLocation(i)) {
			// Need route_2 for the station tile of the other one
			st = this.route_2.GetValue(v);
		}
		local s2_id = AIStation.GetStationID(st);
		local s2_waiting = AIStation.GetCargoWaiting(s2_id, this.passenger_cargo_id);

		list2.Valuate(AIVehicle.GetAge);
		list2.KeepBelowValue(dist);
		/* Do not build a new vehicle if we bought a new one in the last DISTANCE / 2 days */
		if (list2.Count() != 0) continue;

		/* Do not build new vehicle if there isn't at least some waiting cargo at the other station too. */
		if  (s2_waiting <= AIRPORT_CARGO_WAITING_LOW_LIMIT-AIRPORT2_WAITING_DIFF) continue;

		/* Do not build more aircraft if there are too many planes waiting to land at both
		   the airports part of this order. */
		if (Airport.GetNumAircraftInAirportQueue(i, false) > 2) continue;
		
		// TODO: Maybe also check for aircraft waiting in depot because that could be a sign of
		// too many aircraft too!

		AILog.Info("Station " + AIStation.GetName(i) + "(id: " + i +
			") has a lot of waiting passengers (cargo: " + list.GetValue(i) + ")");
		AILog.Info("Other station: " + AIStation.GetName(s2_id) + " waiting passengers: " + s2_waiting);
		AILog.Info("Going to add a new aircraft for this route.");

		/* Make sure we have enough money */
		this.GetMoney(AIRCRAFT_LOW_PRICE);

		/* Build the aircraft. */
		local ret = this.BuildAircraft(this.route_1.GetValue(v), this.route_2.GetValue(v), 0);
		
		/* If we have a real high amount of waiting cargo/passengers then add 2 planes at once. */
		/* Provided buying the first plane went ok. */
		/* Do not build new vehicle if there isn't at least some waiting cargo at the other station too. */
		if ((ret == ALL_OK) && (AIStation.GetCargoWaiting(i, this.passenger_cargo_id) > AIRPORT_CARGO_WAITING_HIGH_LIMIT) &&
			(s2_waiting > AIRPORT_CARGO_WAITING_HIGH_LIMIT-AIRPORT2_WAITING_DIFF)) {
			AILog.Info(" Building a second aircraft since waiting passengers is very high.");
			/* Make sure we have enough money */
			this.GetMoney(AIRCRAFT_LOW_PRICE);
			/* Build the aircraft. */
			ret = this.BuildAircraft(this.route_1.GetValue(v), this.route_2.GetValue(v), 0);
		}
		return ret;
	}
	AILog.Info(Helper.GetCurrentDateString() + " Finished managing air routes.");
}

/**
  * Sells the airports from tile_1 and tile_2
  * Removes towns from towns_used list too
  */
function WormAI::SellAirports(airport_1_tile, airport_2_tile) {
	/* Remove the airports */
	AILog.Info("==> Removing airports " + AIStation.GetName(AIStation.GetStationID(airport_1_tile)) + " and " + 
		AIStation.GetName(AIStation.GetStationID(airport_2_tile)) + " since they are not used anymore");
	this.RemoveAirport(airport_1_tile);
	this.RemoveAirport(airport_2_tile);
	/* Free the towns_used entries */
	this.towns_used.RemoveValue(airport_1_tile);
	this.towns_used.RemoveValue(airport_2_tile);
	// TODO: Make a list of removed airports/tiles so that we don't build a new airport
	// in the same spot soon after we have removed it!
}

function WormAI::HandleEvents()
{
	while (AIEventController.IsEventWaiting()) {
		local e = AIEventController.GetNextEvent();
		switch (e.GetEventType()) {
			case AIEvent.ET_VEHICLE_CRASHED: {
				local ec = AIEventVehicleCrashed.Convert(e);
				local v = ec.GetVehicleID();
				AILog.Warning("We have a crashed aircraft (" + v + "), buying a new one as replacement");
				this.BuildAircraft(this.route_1.GetValue(v), this.route_2.GetValue(v), 0);
				this.route_1.RemoveItem(v);
				this.route_2.RemoveItem(v);
			} break;

			default:
				break;
		}
	}
}

function WormAI::EvaluateAircraft() {
	/* Show some info about what we are doing */
	AILog.Info(Helper.GetCurrentDateString() + " Evaluating aircraft.");
	
	local engine_list = AIEngineList(AIVehicle.VT_AIR);
	//engine_list.Valuate(AIEngine.GetPrice);
	//engine_list.KeepBelowValue(balance < AIRCRAFT_LOW_PRICE_CUT ? AIRCRAFT_LOW_PRICE : (balance < AIRCRAFT_MEDIUM_PRICE_CUT ? AIRCRAFT_MEDIUM_PRICE : AIRCRAFT_HIGH_PRICE));

	engine_list.Valuate(AIEngine.GetCargoType);
	engine_list.KeepValue(this.passenger_cargo_id);

	// Only use this one when debugging:
	//engine_list.Valuate(AIEngine.GetCapacity);
	
	// First fill temporary list with our usefulness factors
	local factor_list = AIList();
	// Remember best engine for logging purposes
	local best_engine = null;
	local best_factor = 10000000; // Very high factor so any engine will be below it
	
	foreach(engine, value in engine_list) {
		// From: http://thegrebs.com/irc/openttd/2012/04/20
		// <frosch123>	both AIOrder::GetOrderDistance and AIEngine::GetMaximumOrderDistance() return 
		// squared euclidian distance
		// <frosch123>	so, you can compare them without any conversion
		// <+michi_cc>	krinn: Always use AIOrder::GetOrderDistance to query the distance.You can pass 
		// tiles that either are part of a station or are not, it will automatically calculate the right thing.
		// <+michi_cc>	AIEngine::GetMaximumOrderDistance and AIOrder::GetOrderDistance complement each other, 
		// and you can always use > or < on the returned values without knowing if it is square, manhatten or 
		// whatever that is applicable for the vehicle type.
		// <krinn>	vehlist.Valuate(AIEngine.GetMaximumOrderDistance); + vehlist.KeepValue(distance*distance)
		local _ayear = 24*365;	// 24 hours * 365 days
		local _eval_distance = 50000;	// assumed distance for passengers to travel
		if (AIEngine.IsValidEngine(engine)) {
			local speed = AIEngine.GetMaxSpeed(engine);
			local cap = AIEngine.GetCapacity(engine);
			local ycost = AIEngine.GetRunningCost(engine);
			//local costfactor = ycost / (speed * cap);
			local distance_per_year = speed * _ayear;
			local pass_per_year = cap * distance_per_year / _eval_distance;
			// No real values thus to get a sensible int value multiply with 100
			local cost_per_pass = (ycost * 100) / pass_per_year;
			if (cost_per_pass < best_factor) {
				best_factor = cost_per_pass;
				best_engine = engine;
			}
			if (GetSetting("debug_show_lists") == 1) {
				// Show info about evaluated engines
				AILog.Info("Engine: " + AIEngine.GetName(engine) + ", price: " + AIEngine.GetPrice(engine) +
					", yearly running costs: " + AIEngine.GetRunningCost(engine));
				AILog.Info( "    Capacity: " + AIEngine.GetCapacity(engine) + ", Maximum speed: " + 
					AIEngine.GetMaxSpeed(engine) + ", Maximum distance: " + AIEngine.GetMaximumOrderDistance(engine) +
					", type: " + GetAircraftTypeAsText(engine));
				AILog.Warning("    Aircraft usefulness factors d: " + distance_per_year + ", p: " + pass_per_year +
					", pass cost factor: " + cost_per_pass);
			}
			// Add the cost factor to our temporary list
			factor_list.AddItem(engine,cost_per_pass);
		}
	}
	this.engine_usefulness.Clear();
	this.engine_usefulness.AddList(factor_list);
	AILog.Info("Evaluated engines count: " + this.engine_usefulness.Count());
	if (!best_engine) {
		AILog.Warning("Best overall engine: <no engine available>");
	}
	else {
		AILog.Warning("Best overall engine: " + AIEngine.GetName(best_engine) + ", cost factor: " + best_factor);
	}
}

function WormAI::GetCostFactor(engine, costfactor_list) {
	// For some reason we can't access this.engine_usefulness from inside the Valuate function,
	// thus we add that as a parameter
	//AILog.Info("usefulness list count: " + costfactor_list.Count());
	if (costfactor_list == null) {
		return 0;
	}
	else {
		return costfactor_list.GetValue(engine);
		//return AIEngine.GetCapacity(engine);
	}
}

function WormAI::CanBuildAircraft()
{
	/* Need to check if we can build aircraft and how many. Since this can change we do it inside the loop. */
	if (AIGameSettings.IsDisabledVehicleType(AIVehicle.VT_AIR)) {
		if (this.aircraft_disabled_shown == 0) {
			AILog.Warning("Using aircraft is disabled in your game settings. Since this AI currently only uses aircraft it will not build anything until you change this setting.")
			this.aircraft_disabled_shown = 1;
		}
	}
	else if (Vehicle.IsVehicleTypeDisabledByAISettings(AIVehicle.VT_AIR)) {
		if (this.aircraft_disabled_shown == 0) {
			AILog.Warning("Using aircraft is disabled in this AI's settings. Since this AI currently only uses aircraft it will not build anything until you change this setting.")
			this.aircraft_disabled_shown = 1;
		}
	}
	else if (Vehicle.GetVehicleLimit(AIVehicle.VT_AIR) == 0) {
		if (this.aircraft_max0_shown == 0) {
			AILog.Warning("Amount of allowed aircraft for AI is set to 0 in your game settings. This means we can't build any aircraft which is currently our only option.")
			this.aircraft_max0_shown = 1;
		}
	}
	else {
		return true;
	}
	return false;
}
/*
 * InitSettings initializes a number of required variables based on the gamesettings of our AI.
*/
function WormAI::InitSettings()
{
	local ai_speed = GetSetting("ai_speed");
	switch (ai_speed) {
		case 1: {this.ai_speed_factor = 3;} break;
		case 3: {this.ai_speed_factor = 1;} break;
		default: {this.ai_speed_factor = 2;} break;
	}
	
	this.delay_build_airport_route = DEFAULT_DELAY_BUILD_AIRPORT * this.ai_speed_factor;
	
	/* Since autorenew can change the vehicle id it may cause trouble to have it turned on,
	 * therefore we turn it off and will renew manually in the future. */
	AICompany.SetAutoRenewStatus(false); 
}

/*
 * Welcome says hello to the user and prints out it's current AI gamesettings.
*/
function WormAI::Welcome()
{
	/* Say hello to the user */
	AILog.Info("Welcome to WormAI. I am currently in development.");
	AILog.Info("These are our current AI settings:");
	AILog.Info("- Use planes: " + GetSetting("use_planes"));
	AILog.Info("- AI speed: " + GetSetting("ai_speed"));
	AILog.Info("- Minimum Town Size: " + GetSetting("min_town_size"));
	AILog.Info("- Minimum Airport Distance: " + GetSetting("min_airport_distance"));
	AILog.Info("- Maximum Airport Distance: " + GetSetting("max_airport_distance"));
	AILog.Info("----------------------------------");
}

function WormAI::Start()
{
	if (this.passenger_cargo_id == -1) {
		AILog.Error("WormAI could not find the passenger cargo");
		return;
	}

	/* Give the boy a name */
	if (!AICompany.SetName("WormAI")) {
		local i = 2;
		while (!AICompany.SetName("WormAI #" + i)) {
			i++;
		}
	}
	this.name = AICompany.GetName(AICompany.COMPANY_SELF);
	
	InitSettings();	// Initialize some AI game settings.
	Welcome();		// Write welcome and AI settings in log.
	
	if (loaded_from_save) {
		/* Debugging info */
		DebugListTownsUsed();
		// We need to redo distance_of_route table
		foreach( veh, tile_1 in route_1) {
			local tile_2 = route_2.GetValue(veh);
			AILog.Info("Vehicle: " + veh + " tile1: " + WriteTile(tile_1) + " tile2: " + WriteTile(tile_2));
			AILog.Info("Distance: " + AIMap.DistanceManhattan(tile_1, tile_2));
			this.distance_of_route.rawset(veh, AIMap.DistanceManhattan(tile_1, tile_2));
		}
		/* Debugging info */
		DebugListRouteInfo();
	}
	
	/* We start with almost no loan, and we take a loan when we want to build something */
	AICompany.SetLoanAmount(AICompany.GetLoanInterval());

	/* We need our local tickers, as GetTick() will skip ticks */
	local old_ticker = 0;
	local cur_ticker = 0;
	/* The amount of time we may sleep between loops.
	   Warning: don't change this value unless your understand the implications for all the delays! 
	*/
	local sleepingtime = SLEEPING_TIME;
	/* Factor to multiply the build delay with. */
	local build_delay_factor = 1;
	
	local cur_year = 0;
	local new_year = 0;
	local cur_month = 0;
	local new_month = 0;

	/* Let's go on forever */
	while (true) {
		cur_ticker = GetTick();
		/* Check if we can build aircraft. If yes then handle some tasks. */
		if (CanBuildAircraft()) {
			/* Once in a while, with enough money, try to build something */
			if (((cur_ticker - old_ticker > build_delay_factor * this.delay_build_airport_route) || old_ticker == 0) 
				&& this.HasMoney(MINIMUM_BALANCE_BUILD_AIRPORT)) {
				local ret = this.BuildAirportRoute();
				if ((ret == ERROR_FIND_AIRPORT1) || (ret == ERROR_MAX_AIRPORTS) ||
					(ret == ERROR_MAX_AIRCRAFT) && old_ticker != 0) {
					/* No more routes found or we have the max allowed aircraft, delay even more before trying to find an other */
					build_delay_factor = 10;
				}
				else {
					/* Set default delay back in case we had it increased, see above. */
					build_delay_factor = 1;
				}
				old_ticker = cur_ticker;
			}

			/* Check for events once in a while */
			this.HandleEvents();
			
			/* Task scheduling. */
			new_year = AIDate.GetYear(AIDate.GetCurrentDate());
			if (cur_year < new_year) {
				// Handle once a year tasks here.
				AILog.Info(Helper.GetCurrentDateString() + " --- Yearly Tasks ---");
				cur_year = new_year;
				
				/* Some things we do more or less often depending on this.ai_speed_factor setting */
				if (cur_year % this.ai_speed_factor == 0) {
					this.EvaluateAircraft();
					}
				
				/* This seems like a good place to show some debugging info in case we turned
				   that setting on. Always once a year. */
				if (GetSetting("debug_show_lists") == 1) {
					/* Debugging info */
					DebugListTownsUsed();
					//DebugListRouteInfo();
					DebugListRoutes();
				}
				
				AILog.Info(Helper.GetCurrentDateString() + " --- Yearly Tasks Done ---");
			}
			new_month = AIDate.GetMonth(AIDate.GetCurrentDate());
			if (cur_month != new_month) { // Don't use < here since we need to handle December -> January
				// Handle once a month tasks here.
				AILog.Info(Helper.GetCurrentDateString() + " --- Monthly Tasks ---");
				cur_month = new_month;

				/* Some things we do more or less often depending on this.ai_speed_factor setting */
				if (cur_month % this.ai_speed_factor == 0) {
					/* Manage the routes once in a while */
					this.ManageAirRoutes();
				}

				CheckForAirportsNeedingToBeUpgraded();
				ManageVehicleRenewal(VEHICLE_AGE_LEFT_LIMIT);
				/* TEST ONCE A MONTH? SELL VEHICLES IN DEPOT */
				SellVehiclesInDepot();
				
				/* Try to get rid of our loan once in a while */
				AICompany.SetLoanAmount(0);
				
				AILog.Info(Helper.GetCurrentDateString() + " --- Monthly Tasks Done ---");
			}
		}

		/* Make sure we do not create infinite loops */
		Sleep(sleepingtime);
	} // END OF OUR MAIN LOOP
}

 function WormAI::Save()
 {
   /* Debugging info */
	local MyOps1 = this.GetOpsTillSuspend();
	local MyOps2 = 0;
/* only use for debugging:
    AILog.Warning("Saving data to savegame not implemented yet!");
    AILog.Info("Ops till suspend: " + this.GetOpsTillSuspend());
    AILog.Info("");
*/
    /* Save the data */
    local table = {
		townsused = null,
		route1 = null,
		route2 = null,
	};
	local t = ExtendedList();
	local r1 = ExtendedList();
	local r2 = ExtendedList();
	t.AddList(this.towns_used);
	table.townsused = t.toarray();
	r1.AddList(this.route_1);
	table.route1 = r1.toarray();
	r2.AddList(this.route_2);
	table.route2 = r2.toarray();
	
    /* Debugging info 
    DebugListTownsUsed();
    DebugListRouteInfo();
*/   
/* only use for debugging:
    AILog.Info("Tick: " + this.GetTick() );
*/
    MyOps2 = this.GetOpsTillSuspend();
	if (MyOps2 < 10000) {
		AILog.Error("SAVE: Using almost all allowed ops: " + MyOps2 );
	}
	else if (MyOps2 < 20000) {
		AILog.Warning("SAVE: Using a high amount of ops: " + MyOps2 );
	}
	else {
		AILog.Info("Saving WormAI game data. Used ops: " + (MyOps1-MyOps2) );
	}
   
    return table;
 }
 
 function WormAI::Load(version, data)
 {
   /* Debugging info */
	local MyOps1 = this.GetOpsTillSuspend();
	local MyOps2 = 0;
	AILog.Info("Loading savegame saved by WormAI version " + version);
	// TODO: load data in temp values then later unpack it because
	// load has limited time available
	if ("townsused" in data) {
		local t = ExtendedList();
		t.AddFromArray(data.townsused)
		towns_used.AddList(t);
	}
	if ("route1" in data) {
		local r = ExtendedList();
		r.AddFromArray(data.route1)
		route_1.AddList(r);
	}
	if ("route2" in data) {
		local r = ExtendedList();
		r.AddFromArray(data.route2)
		route_2.AddList(r);
	}
	loaded_from_save = true;

    /* Debugging info */
    MyOps2 = this.GetOpsTillSuspend();
	if (MyOps2 < 10000) {
		AILog.Error("LOAD: Using almost all allowed ops: " + MyOps2 );
	}
	else if (MyOps2 < 20000) {
		AILog.Warning("LOAD: Using a high amount of ops: " + MyOps2 );
	}
	else {
		AILog.Info("Loading WormAI game data. Used ops: " + (MyOps1-MyOps2) );
		//AILog.Info("Loading: ops till suspend: " + MyOps2 + ", ops used in load: " + (MyOps1-MyOps2) );
	}
 }
 